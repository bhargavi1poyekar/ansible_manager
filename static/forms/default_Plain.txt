Confidentiality With Symmetric Encryption. The universal technique for providing confidentiality for transmitted or stored data is symmetric encryption. This section introduces the basic concept of symmetric encryption. This is followed by an overview of the two most important symmetric encryption algorithms the Data Encryption Standard DES and the Advanced Encryption Standard AES which are block encryption algorithms. Finally this section introduces the concept of symmetric stream encryption algorithms. Symmetric encryption was the only type of encryption in use prior to the introduction of public-key encryption.

We need a strong encryption algorithm. At a minimum we would like the algorithm to be such that an opponent who knows the algorithm and has access to one or more ciphertexts would be unable to decipher the ciphertext or figure out the key. This requirement is usually stated in a stronger form: The opponent should be unable to decrypt ciphertext or discover the key even if he or she is in possession of a number of ciphertexts together with the plaintext that produced each ciphertext. The sender and receiver must have obtained copies of the secret key in a secure fashion and must keep the key secure.

There is more to a brute force attack than simply running through all possible keys. Unless known plaintext is provided the analyst must be able to recognize plaintext as plaintext. If the message is just plain text in English then the result pops out easily although the task of recognizing English would have to be automated rather than manual recognition. If the text message has been compressed before encryption then recognition becomes more difficult. And if the message is some more general type of data such as a numerical file and this has been compressed then the problem becomes even more difficult to automate.

Concerns about the strength of Data Encryption Standard DES fall into two categories.  First one is concern about the algorithm itself and second one is the concern about the use of a Fifty Six bit key. The first concern refers to the possibility that cryptanalysis is possible by exploiting the characteristics of the DES algorithm. Are there any inherent weaknesses in it. Over the years there have been a number of attempts to find and exploit weaknesses in the algorithm. This makes DES the most studied encryption algorithm in existence. Despite numerous approaches no one has so far reported a fatal weakness in DES.

Three DES has two attractions that assure its widespread use over the next few years. First with its One Sixty Eight bit key length. it overcomes the vulnerability to brute force attack of Data Encryption Standard. Second the underlying encryption algorithm in  Three DES is the same as in DES. This algorithm has been subjected to more scrutiny than any other encryption algorithm over a longer period of time and no effective cryptanalytic attack based on the algorithm rather than brute force has been found. Accordingly there is a high level of confidence that Three DES is very resistant to cryptanalysis.

Typically symmetric encryption is applied to a unit of data which is larger than a single Sixty Four bits or One Twenty Eight bits block. Email messages or network packets or database records or any other plaintext sources must be broken up into a series of fixed size length block for encryption by a symmetric block cipher. Each such block of data is encrypted separately. The simplest approach to multiple block encryption is known as electronic codebook ECB mode. In this mode plaintext is handled b bits at a time and each block of plaintext is encrypted using the same key. A plain text of length nb is divided into n b bit blocks.

A typical stream cipher method encrypts the plaintext one byte at a time although a stream cipher may be designed to operate on one bit at a time or on units larger than a byte at a time. Figure Two.Two b is a representative diagram of stream cipher structure. In this structure a key is input to a pseudorandom bit generator that produces a stream of eight bit numbers that are apparently random. A pseudorandom stream is one that is unpredictable without knowledge of the input key and which has an apparently random character. The output of the generator is combined one byte at a time with the plaintext stream.

With a properly designed pseudorandom number generator, a stream cipher can be as secure as a block cipher of comparable key length. The primary advantage of a stream cipher is that stream ciphers are almost always faster and use far less code than do block ciphers. The advantage of a block cipher is that you can reuse keys. For applications that require encryption/decryption of a stream of data, such as over a data communications channel or a browser/Web link, a stream cipher might be the better alternative. For applications that deal with blocks of data, such as file transfer block ciphers may be more appropriate.

A message or a file or a document or some other collection of data is said to be authentic when it is genuine and came from its alleged source. Message or data authentication is a procedure that allows communicating parties to verify that received or stored messages are authentic i.e. came from original source. The two important aspects are to verify that the contents of the message have not been altered and that the source is authentic. We may also wish to verify timeliness of a message and sequence relative to other messages flowing between two parties. All of these concerns come under the category of data integrity.

It seems possible to perform message authentication simply by the use of symmetric encryption mechanism. If we assume that only the sender and receiver share a key exclusively then only the genuine sender would be able to encrypt a message successfully for the other participant provided the receiver can recognize a valid message. Furthermore if the message includes an error detection code and a sequence number the receiver is assured that no alterations have been made and that sequencing is not tempered with i.e. reordered. If the message also includes a timestamp the receiver is assured that the message has not been delayed.

When we do not encrypt the message then confidentiality is not provided. As mentioned message encryption by itself does not imply authentication. However it is possible to combine authentication and confidentiality in a single algorithm by encrypting a message plus its authentication tag. Typically however message authentication is provided as a separate function from message encryption. Literature suggests three situations in which message authentication without confidentiality is preferable. One example is when a message is broadcasted to many destinations. Othe example would be when encrytion is too compute intensive.

There are a number of applications in which the same message is broadcast to a number of destinations. Two examples are notification to users that the network is now unavailable and an alarm signal in a control center. It is cheaper and more reliable to have only one destination responsible for monitoring authenticity. Thus the message must be broadcast in plaintext with an associated message authentication tag. The responsible system performs authentication to ensures that message has not been tempered with. When a violation is detected then the other destination systems are alerted by a general alarm.

Another possible scenario is an exchange in which one side has a heavy load and cannot afford the time to decrypt all incoming messages. Authentication is carried out on a selective basis with messages being chosen at random for checking. Authentication of a computer program in plaintext is an attractive service. The computer program can be executed without having to decrypt it every time which would be wasteful of processor resources. Howeve, if a message authentication tag were attached to the program it could be checked whenever assurance is required of the integrity of the program.

Message Authentication Using a Message Authentication Code works as follows. The receiver is assured that the message has not been altered. If an attacker alters the message but does not alter the code then the receivers calculation of the code will differ from the received code. Because the attacker is assumed not to know the secret key the attacker cannot alter the code to correspond to the alterations in the message. The receiver is assured that the message is from the alleged sender. Because no one else knows the secret key no one else could prepare a message with a proper code. Further it can include a sequence number.

An alternative approach to the message authentication code is the one way hash function. As with the message authentication code a hash function accepts a variable size message M as input and produces a fixed size message digest H as output after some computation on M. Typically the message is padded out to an integer multiple of some fixed length for example One Thousand Twenty Four bits and the padding includes the value of the length of the original message in bits. The length field is a security measure to increase the difficulty for an attacker to produce an alternative message with the same hash value.

Unlike the MAC, a hash function does not take a secret key as input. It illustrates three ways in which the message can be authenticated using a hash function. The message digest can be encrypted using symmetric encryption. If it is assumed that only the sender and receiver share the encryption key then authenticity is assured. The message digest can also be encrypted using public key encryption. This is explained in Section two.three. The public key approach has two advantages. It provides a digital signature as well as message authentication and it does not require the distribution of keys to communicating parties.

Generally entire message is not encrypted. Encryption software is quite slow. Even though the amount of data to be encrypted per message is small there may be a steady stream of messages into and out of a system. Encryption hardware costs are nonnegligible. Low cost chip implementations of DES and AES are available but the cost adds up if all nodes in a network must have this capability. Encryption hardware is optimized toward large data sizes. For small blocks of data a high proportion of the time is spent in initialization invocation overhead. An encryption algorithm may be protected by a patent.

Basic Requirements for Hash Function. The purpose of a hash function is to produce a fingerprint of a File or Message or other block of data. To be useful for message authentication a hash function H must have the following properties. H can be applied to a block of data of any size. H always produces a fixed length output. Hash of message M is relatively easy to compute for any given M. This makes both hardware and software implementations practical. For any given hash code H it is computationally infeasible to find M.  A hash function with this property is referred to as one way or preimage resistant.

Hash Function Requirements. The fifth requirement guarantees that it is impossible to find an alternative message with the same hash value as a given message. This prevents forgery when an encrypted hash code is used. If this property were not true an attacker would be capable forging a message using the following sequence. First observe or intercept a message plus its encrypted hash code. Second generate an unencrypted hash code from the message. Third generate an alternate message with the same hash code. Thus receiver would not know that incoming data or message has been compromised.

A hash function that satisfies the first five properties in the list is referred to as a weak hash function. If the sixth property is also satisfied then it is referred to as a strong hash function. A strong hash function protects against an attack in which one party generates a message for another party to sign. For example suppose Alice agrees to sign an IOU for a small amount with Bob. Suppose Bob can find two messages with the same hash value. First one requires Alice to pay the small amount and second one requires a large payment. Alice signs the first message and Bob claims that the second message is authentic.

In recent years, the most widely used hash function has been the Secure Hash Algorithm. SHA was developed by the National Institute of Standards and Technology  and published as a federal information processing standard FIPS Nineteen Ninety Three. When weaknesses were discovered in SHA, a revised version was issued in Nineteen Ninety Five and is generally referred to as SHA one. SHA one produces a hash value of One Sixty bits. In Two Thousand Two NIST produced a revised version of the standard FIPS two.  It defined three new versions of SHA with hash value lengths of Two Fifty Six or Three Eighty Four or Five hundred twelve bits.

We have discussed the use of hash functions for message authentication and for the creation of digital signatures. Here are is an examples of secure hash function application. Passwords. In this scheme a hash of a password is stored by an operating system rather than the password itself. Thus the actual password is not retrievable by a hacker who gains access to the password file. In simple terms when a user enters a password the hash of that password is compared to the stored hash value for verification. This application requires preimage resistance and perhaps second preimage resistance.

We have discussed the use of hash functions for message authentication and for the creation of digital signatures. Here are is an examples of secure hash function application. Intrusion detection. In this scheme we store the hash value HF for a file for each file on a system and secure the hash values for example on a write locked drive or write once optical disk that is kept secure. One can later determine if a file has been modified by recomputing HF. An intruder would need to change content of file F without changing its hash value HF. This application requires weak second preimage resistance.

Public key encryption first publicly proposed by Diffie and Hellman in nineteen Seventy Six is the first truly revolutionary advance in encryption in literally thousands of years. Public key algorithms are based on mathematical functions rather than on simple operations on bit patterns such as are used in symmetric encryption algorithms. More important public key cryptography is asymmetric. It involves the use of two separate keys in contrast to symmetric encryption which uses only one key. The use of two keys has profound consequences in the areas of confidentiality key distribution and authentication.

There are several common misconceptions concerning public key encryption. One is that it is more secure from cryptanalysis than symmetric encryption. In fact the security of any encryption scheme depends on two things. First the length of the key and second the computational work involved in breaking a cipher. There is nothing in principle about either symmetric or public key encryption that makes one superior to another from the point of view of resisting cryptanalysis. A second misconception is that public key encryption is a general purpose technique that has made symmetric encryption obsolete.

Misconception about public key encryption. Because of the computational overhead of current public key encryption schemes there seems no foreseeable likelihood that symmetric encryption will be abandoned. Finally there is a feeling that key distribution is trivial when using public key encryption compared to the rather cumbersome handshaking involved with key distribution centers for symmetric encryption. For public key key distribution, some form of protocol is needed which often involves a central agent and the procedures involved are no simpler or any more efficient than those required for symmetric encryption.

Terms used in Public key encryption. Public and private key is a pair of keys that have been selected so if one is used for encryption the other is used for decryption. The exact transformations performed by the encryption algorithm depend on the public or private key that is provided as input. Ciphertext is the scrambled message produced as output. It depends on the plaintext and the key. For a given message two different keys will produce two different ciphertexts. Decryption algorithm is an algorithm that accepts the ciphertext and the matching key and produces the original plaintext.

The essential steps in public key encryption are as  follows. Each user generates a pair of keys to be used for the encryption and decryption of messages. Each user places one of the two keys in a public  accessible place. This is the public key. The companion key is kept private. Each user maintains a collection of public keys obtained from others. If Bob wishes to send a private message to Alice then Bob encrypts the message using public key of Alice. When Alice receives the message she decrypts it using her private key. No other recipient can decrypt the message because only Alice knows her private key.

The scheme of private key encryption is directed toward providing authentication and or data integrity. If a user is able to successfully recover the plaintext from Bobs ciphertext using Bobs public key this indicates only Bob could have encrypted the plaintext thus providing authentication. Further no one but Bob would be able to modify the plaintext because only Bob could encrypt the plaintext with Bobs private key. Once again, the actual provision of authentication or data integrity depends on a variety of factors. This issue will be addressed later but other references are made to it where appropriate in this text.

The scheme of encryption with public key is directed toward providing confidentiality of message. This scheme ensures that only the intended recipient should be able to decrypt the original ciphertext as sent by sender because only the intended recipient is in possession of the required private key. No other person should be able to decrypt the message. Whether in fact confidentiality is provided or not depends on a number of factors which includes the following. It could be security of the algorithm or whether the private key is kept secure and the security of any protocol of which the encryption function is a part.

Applications for Public-Key Cryptosystems. Public key systems are characterized by the use of a cryptographic type of algorithm with two keys. one key is held private and one key is made available publicly. Depending on the application under consideration the sender uses either the private key of the sender or the public key of the receiver. It can do both to perform some type of cryptographic function. In broad terms we can classify the use of public key cryptosystems into three categories. First one is digital signature. Second one symmetric key distribution and third one encryption of secret keys.

RSA algorithm. One of the first public key schemes was developed in the year One Thousand Nine Hundred and Seventy Seven by three inventor Ron Rivest Adi Shamir and Len Adleman at MIT. It was first published one year later. The RSA scheme has since reigned supreme as the most widely accepted and implemented approach to public key encryption. RSA algorithm is a block cipher in which the plaintext and ciphertext are considered as integers between zero and n minus one for some n. They offered a reward of hundred dollars for the return of a plaintext sentence an event they predicted might not occur for some forty quadrillion years.

In April of Nineteen Ninety Four a group working over the Internet and using over one thousand six hundred computers claimed the prize as announced by Rivest Shamir and Adleman after only eight months of work. This challenge used a public key size with length of n of one twenty nine decimal digits or around four hundred twenty bits. This result does not invalidate the use of RSA algorithm but it simply means that larger key sizes must be used. Currently a one thousand twenty four bit key size which is about three hundred decimal digits is considered strong enough for virtually all applications.

Diffie Hellman Key Agreement algorithm. The first published public key algorithm appeared in the seminal paper by Diffie and Hellman that defined public key cryptography  and is generally referred to as Diffie Hellman key exchange or key agreement. A number of commercial products employ this key exchange technique. The purpose of the algorithm is to enable two users to securely reach agreement about a shared secret that can be used as a secret key for subsequent symmetric encryption of messages. The algorithm itself is limited to the exchange of the keys. The algorithm in its simplistic terms is subject to MITM attack.

Digital Signature Standard. The National Institute of Standards and Technology NIST published this originally as FIPS PUB one eighty six. The DSS makes use of SHA one and presents a new digital signature technique the Digital Signature Algorithm DSA. The DSS was originally proposed in Nineteen Ninety one and revised later in response to public feedback concerning the security of the scheme. There were further revisions in subsequent years and most recently in Two Thousand Thirteen as FIPS PUB one eighty six dash four. The DSS is designed to provide only the digital signature function and cannot be used for encryption or key exchange.

Elliptic Curve Cryptography. The vast majority of the products and standards that use public key cryptography for encryption and digital signatures use RSA. The bit length for secure RSA use has increased over recent years and this has put a heavier processing load on applications. This has ramifications  for ecommerce sites that conduct large numbers of secure transactions. Recently, a competing system has begun to challenge RSA known as elliptic curve cryptography or ECC. Already ECC is showing up in standardization efforts including the IEEE Standard for Public-Key Cryptography.

Public key encryption was first publicly proposed by Diffie and Hellman and is the first truly revolutionary advance in encryption in literally thousands of years. Public key algorithms are based on mathematical functions rather than on simple operations on bit patterns such as are used in symmetric encryption algorithms. More important public key cryptography is asymmetric which involves the use of two separate keys in contrast to symmetric encryption which uses only one key. The use of two keys has profound consequences in the areas of confidentiality and key distribution and authentication.

Digital Signature process works on the following lines. Suppose Bob wants to send a message to Alice. Although it is not important that the message be kept secret Bob wants Alice to be certain that the message is indeed from him. For this purpose Bob uses a secure hash function, such as SHA five one two to generate a hash value for the message. That hash value together with  private key of Bob serve as input to a digital signature generation algorithm that produces a short block that functions as a digital signature. Bob sends the message with the signature attached to Alice. Alice will verify the message using digital signature.

Digital Signature process works on the following lines. When Alice receives the message plus signature she  calculates a hash value for the message. She provides the hash value and Bobs public key as inputs to a digital signature verification algorithm. If the algorithm returns the result that the signature is valid Alice is assured that the message must have been signed by Bob. No one else has Bobs private key and therefore no one else could have created a signature that could be verified for this message with Bobs public key. In addition it is impossible to alter the message without access to Bobs private key.

Public key certificates. If there is some broadly accepted public key algorithm then any participant can send his or her public key to any other participant or broadcast the key to the community at large. Although this approach is convenient it has a major weakness. Anyone can forge such a public announcement. That is some user could pretend to be Bob and send a public key to another participant or broadcast such a public key. Until such time as Bob discovers the forgery and alerts other participants the forger is able to read all encrypted messages intended for Bob and can use the forged keys for authentication.

A public key certificate consists of a public key plus a user identity of the key owner with the whole block signed by a trusted third party. The certificate also includes some information about the third party plus an indication of the period of validity of the certificate. Typically the third party is a certificate authority that is trusted by the user community such as a government agency. A user can present his or her public key to the authority in a secure manner and obtain a signed certificate. The user can then publish the certificate. Anyone needing this users public key can obtain the certificate and verify its validity.

A fundamental requirement for two parties to communicate securely is that they share a secret key. Suppose Bob wants to create an application that will enable him to exchange email securely with anyone who has access to the Internet. Suppose Bob wants to do this using symmetric encryption. With symmetric encryption Bob and his correspondent say Alice must come up with a way to share a unique secret key that no one else knows. If Alice is in the next room from Bob Bob could generate a key and write it down on a piece of paper or store it on a disk or thumb drive and hand it to Alice. But the real world is different.

If Alice is in the next room from Bob then Bob could generate a key and write it down on a piece of paper or store it on a disk or thumb drive and hand it to Alice. But if Alice is on the other side of the continent or the world what can Bob do. He could encrypt this key using symmetric encryption and email it to Alice. But this means that Bob and Alice must share a secret key to encrypt this new secret key. Furthermore Bob and everyone else who uses this new email package faces the same problem with every potential correspondent. The problem is each pair of correspondents must share a unique secret key.

Another application in which public key encryption is used to protect a symmetric key is the digital envelope which can be used to protect a message without needing to first arrange for sender and receiver to have the same secret key. The technique is referred to as a digital envelope which is the equivalent of a sealed envelope containing an unsigned letter. The general approach works as follows. Suppose Bob wishes to send a confidential message to Alice but they do not share a symmetric secret key. Bob does the following. Prepare a message. Generate a random symmetric key that will be used this one time only.

It is now routine for businesses to provide a variety of protections including encryption for information that is transmitted across networks via the Internet or via wireless devices.  Once data are stored locally which is referred to as data at rest then there is often little protection beyond domain authentication and operating system access controls. Data at rest are often routinely backed up to secondary storage such as optical media tape or removable disk archived for indefinite periods. Further even when data are erased from a hard disk until the relevant disk sectors are reused the data are recoverable.